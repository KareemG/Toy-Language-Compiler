
We designed our jcup rules to match the reference grammar as much as possible. In fact, the reference grammar and the compiler
grammar are nearly laid out the exact same way. But two notable changes were required due to the strictness of LALR. 

One of the most obvious examples of this is how statements, variable names, etc. need to be split into rules which are recursive on one side and
not both. To fix this, we made rules such as statement_list, variable_name_list, etc. which were left recursive. This solution also helped make the
behaviour of the if statement more explicit; it clearly conveys the message that an if statement can either have a single statement or a scope which
contains a statement list.

Furthermore, the reference grammar had many rules which reduced to a single identifier (i.e. function name, procedure name, variable name, etc.).
But these types of rules introduce shift/reduce errors because of ambiguity (which rule to use). To fix these errors in the compiler grammar, we
simply used identifiers instead of specifying the type of object the name refers to.

Apart from these two complications, implementing the rest of the grammar was fairly straight forward, likely because it is well designed and simple.
