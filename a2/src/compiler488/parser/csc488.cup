/*
    DEFINITIONS for CSC488S Source Language Winter 2016
*/

package compiler488.parser;

// TODO: You can add Java import statements here as necessary

/*
    SYMBOL LISTS

    CUP reserved words are case-sensitive and cannot be used as names of
    terminals or non-terminals. This list includes the following:

        action code extends import init left non nonassoc nonterminal package
        parser precedence right scan start super terminal with

*/

// Keyword terminals returned by the scanner (with no value attached):
terminal AND, OR, NOT, TRUE, FALSE;
terminal BOOLEAN, INTEGER, FUNCTION, PROCEDURE;
terminal DO, ELSE, EXIT, IF;
terminal READ, REPEAT, RETURN, NEWLINE, THEN, UNTIL;
terminal VAR, WHEN, WHILE, WITH, WRITE;

// Special-character terminals (with no value attached):
terminal L_PAREN, R_PAREN, L_SQUARE, R_SQUARE, L_CURLEY, R_CURLEY;
terminal EQUAL, GREATER, LESS, COMMA, DOT, QUESTION, COLON;
terminal PLUS, MINUS, TIMES, DIVIDE;
terminal UMINUS;
terminal L_EQUAL, G_EQUAL, NOT_EQUAL;

// Terminals returned by the scanner that carry a value of a specific Java type:
terminal String     IDENT;
terminal Integer    INTCONST;
terminal String     TEXTCONST;

/*
    To define non-terminals that return no value:

        nonterminal nameList;

    To define non-terminals that do return a value (think AST generation):

        nonterminal JavaType nameList;
*/

nonterminal program, scope, variable, variable_list, expression, statement, statement_list,
            output, output_list, declaration, declaration_list, bound, general_bound,
            variable_name, variable_name_list, type, argument_list, parameter_list, parameter,
            array_member;

// precedence left COMMA;
precedence nonassoc ELSE;
precedence nonassoc IF;
// precedence right WRITE;
// precedence right IDENT;
// precedence right VAR;

precedence left OR;
precedence left AND;
precedence right NOT;
precedence nonassoc EQUAL, NOT_EQUAL, LESS, L_EQUAL, GREATER, G_EQUAL;
precedence left PLUS, MINUS;
precedence left DIVIDE, TIMES;
precedence left UMINUS;

/*
    GRAMMAR SECTION
*/

// This specifies the initial symbol of the grammar.
start with program;

/*
    Notice that sometimes the action must be inside the production rule, not after
    it. This is a subtle yet significant difference from YACC. This is because the
    CUP parser is looking ahead one token. It ALWAYS reads one more token before it
    will act on the production.
 */

// The main program.
program ::= scope;

statement ::= variable COLON EQUAL expression {: System.out.println("VAR DECL"); :}
    | IF expression THEN statement {: System.out.println("IF"); :}
    | IF expression THEN statement ELSE statement {: System.out.println("IF ELSE"); :}
    | WHILE expression DO statement {: System.out.println("WHILE DO"); :}
    | REPEAT statement UNTIL expression {: System.out.println("REPEAT UNTIL"); :}
    | EXIT {: System.out.println("EXIT"); :}
    | EXIT INTCONST {: System.out.println("EXIT INTCONST"); :}
    | EXIT WHEN expression {: System.out.println("EXIT WHEN"); :}
    | EXIT INTCONST WHEN expression {: System.out.println("EXIT INTCONST WHEN"); :}
    | RETURN WITH expression {: System.out.println("RETURN WITH"); :}
    | RETURN {: System.out.println("RETURN"); :}
    | WRITE output_list {: System.out.println("WRITE"); :}
    | READ variable_list {: System.out.println("READ"); :}
    | IDENT {: System.out.println("VAR OR PROC"); :} // procedure call without arguments 
    | IDENT L_PAREN argument_list R_PAREN {: System.out.println("PROC"); :} // procedure call with arguments
    | scope {: System.out.println("SCOPE"); :};

statement_list ::= statement {: System.out.println("STATEMENT"); :}
    | statement_list statement;

expression ::= INTCONST {: System.out.println("CONST INT"); :}
    | MINUS expression {: System.out.println("NEG"); :} %prec UMINUS
    | expression PLUS expression {: System.out.println("+"); :}
    | expression MINUS expression {: System.out.println("-"); :}
    | expression TIMES expression {: System.out.println("*"); :}
    | expression DIVIDE expression {: System.out.println("/"); :}
    | TRUE {: System.out.println("T"); :}
    | FALSE {: System.out.println("F"); :}
    | NOT expression {: System.out.println("!"); :}
    | expression AND expression {: System.out.println("&"); :}
    | expression OR expression {: System.out.println("|"); :}
    | expression EQUAL expression {: System.out.println("="); :}
    | expression NOT EQUAL expression {: System.out.println("!="); :} %prec NOT_EQUAL
    | expression LESS expression {: System.out.println("<"); :}
    | expression LESS EQUAL expression {: System.out.println("<="); :} %prec L_EQUAL
    | expression GREATER expression {: System.out.println(">"); :}
    | expression GREATER EQUAL expression {: System.out.println(">="); :} %prec G_EQUAL
    | L_PAREN expression R_PAREN {: System.out.println("subexpr"); :}
    | L_PAREN expression QUESTION expression COLON expression R_PAREN {: System.out.println("?"); :}
    | IDENT {: System.out.println("ident"); :} // variable name or function call without arguments
    | IDENT L_PAREN argument_list R_PAREN {: System.out.println("func with args"); :} // function call with arguments
    | array_member {: System.out.println("index"); :};

declaration_list ::= declaration {: System.out.println("DECLARATION"); :}
    | declaration_list declaration;

declaration ::= VAR variable_name_list COLON type {: System.out.println("DECL VAR"); :}
    | FUNCTION IDENT COLON type scope {: System.out.println("DECL FUNC"); :}
    | FUNCTION IDENT L_PAREN parameter_list R_PAREN COLON type scope {: System.out.println("DECL FUNC"); :}
    | PROCEDURE IDENT scope {: System.out.println("DECL PROC"); :}
    | PROCEDURE IDENT L_PAREN parameter_list R_PAREN scope {: System.out.println("DECL PROC"); :};

variable_name ::= IDENT
    | IDENT L_SQUARE bound R_SQUARE
    | IDENT L_SQUARE bound COMMA bound R_SQUARE;

variable_name_list ::= variable_name
    | variable_name_list COMMA variable_name;

output ::= expression {: System.out.println("EXPRESSION"); :}
    | TEXTCONST:str {: System.out.println("CONST STR: " + str); :}
    | NEWLINE {: System.out.println("NEWLINE"); :};

output_list ::= output
    | output_list COMMA output;

bound ::= INTCONST
    | general_bound DOT DOT general_bound;

general_bound ::= INTCONST
    | MINUS INTCONST;

variable ::= IDENT | array_member;
    
array_member ::= IDENT L_SQUARE expression R_SQUARE
    | IDENT L_SQUARE expression COMMA expression R_SQUARE;

variable_list ::= variable
    | variable_list COMMA variable;

scope ::= L_CURLEY declaration_list statement_list R_CURLEY
    | L_CURLEY statement_list R_CURLEY
    | L_CURLEY R_CURLEY;

type ::= INTEGER
    | BOOLEAN;

argument_list ::= expression
    | argument_list COMMA expression;

parameter ::= IDENT COLON type;

parameter_list ::= parameter
    | parameter_list COMMA parameter;

