% 3-2
PUSHMT 			% set initial display
SETD 0

% 3-3
PUSH UNDEFINED 		% a
PUSH UNDEFINED 		% b
PUSH UNDEFINED 		% c
PUSH UNDEFINED 		% d

% 3-4
PUSH UNDEFINED 		% p
PUSH UNDEFINED 		% q
PUSH UNDEFINED 		% r
PUSH UNDEFINED 		% s

% 3-5
PUSH 3-12 		% Branch over procedure P
BR

% ===== procedure P =====
PUSHMT 			% set display for P
SETD 1

% 3-7
PUSH UNDEFINED 		% e
PUSH UNDEFINED 		% f

% 3-8
ADDR 0 4 		% load p
LOAD
PUSH 3-10		% address over if branch
BF
POP2 			% free local variables
ADDR 1 0 		% load return address
BR 			% branch to return address

% 3-9
ADDR 1 2 		% addr of e
ADDR 0 0 		% load a
LOAD
STORE 			% store a to e

% 3-10
POP2 			% free local variables
ADDR 1 0 		% load return address
BR

% 3-12
PUSH 3-17 		% branch over function F
BR

% ===== function F ======
PUSHMT 			% set display for F
SETD 1

% 3-14
ADDR 1 4 		% load n
LOAD
PUSH 3-15		% address over if branch
BF 			% branch if n is MACHINE_FALSE
ADDR 1 0 		% get the address for return val
ADDR 1 3 		% load m
LOAD
ADDR 0 1 		% load b
LOAD
ADD 			% m + b
STORE 			% store m + b to ret val
ADDR 1 2 		% restore display address 1 to previous address
SETD 1
ADDR 1 1 		% load return address
BR

% 3-15
ADDR 1 0 		% get the address for return val
ADDR 0 2 		% load c
LOAD
ADDR 1 3 		% load m
LOAD
SUB 			% c - m
STORE 			% store c - m to ret val
ADDR 1 1 		% load return address
BR

% 3-17
PUSH 3-28 		% branch over function Q
BR

% ===== procedure Q =====
PUSHMT 			% set display for F
SETD 1

% 3-19
PUSH UNDEFINED 		% t
PUSH UNDEFINED 		% u
PUSH UNDEFINED 		% v

% 3-20
PUSH 3-26 		% branch over function G
BR

% ====== function G =====
PUSHMT 			% set display for G
SETD 2

% 3-22
PUSH UNDEFINED 		% w
PUSH UNDEFINED 		% x

% 3-23
ADDR 2 0 		% get the address for return val

% 3-24
ADDR 1 3 		% load m
LOAD
PUSH 3-24.1 		% address which points to "PUSH MACHINE_FALSE"
BF
ADDR 1 5 		% load p
LOAD
PUSH MACHINE_FALSE 	% negate p
EQ
PUSH 3-24.2 		% address which points to "PUSH 3-24.3"
BR
PUSH MACHINE_FALSE 	% "m and not p" is false
PUSH 3-24.3 		% address which points to false expression
BF
% true expression
ADDR 1 8 		% load v
LOAD
ADDR 1 3 		% load m
LOAD
LT 			% v < m
PUSH 3-24.4 		% address which points over false expression
BR
% false expression
ADDR 0 6 		% load r
LOAD
PUSH MACHINE_FALSE 	% negate r
EQ
PUSH 3-24.5 		% address which points to "PUSH MACHINE_FALSE"
BF
ADDR 0 7 		% load s
LOAD
PUSH 3-24.6 		% address which points to "STORE"
BR
PUSH MACHINE_FALSE 	% "not r and s" is false
STORE 			% store "(m and not p ? v < u : not r and s)" to ret val
POP0 			% free local variables
ADDR 2 1 		% load return address
BR

% 3-26
PUSH UNDEFINED 		% allocate space for return value
PUSH 3-26.1 		% set return address (points to "ADDR 1 2")
ADDR 1 0 		% push existing display 1 address
% parameter "m"
ADDR 1 6 		% load t
LOAD
ADDR 1 4 		% load n
LOAD
SUB 			% t - n
ADDR 0 0 		% load a
LOAD
ADD 			% (t - n) + a
% paramaeter "n"
PUSH UNDEFINED 		% allocate space for return value
PUSHMT 			% set return address
ADDR 1 0 		% push existing display 2 address
PUSH 3-21 		% address of function G
BR 			% call function G
ADDR 2 2 		% restore display register
SETD 2
POP2 			% clear activation record except return value
PUSH MACHINE_FALSE 	% negate G
EQ
ADDR 0 6 		% load r
LOAD
OR 			% not G or r
% calling function F
PUSH 3-14 		% address of function F
BR 			% call function F (t - n + a, not G or r)
ADDR 1 2 		% restore display register
SETD 1
POP4 			% clear activation record except return value
% calling function F END
PRINTI 			% print the return value of F
PUSH '\n' 	 	% push newline onto stack
PRINTC 			% print newline

% 3-28
% procedure Q call
PUSH 3-28.1 		% load return address (points to 
ADDR 1 0 		% push existing display 1 address
% parameter m
ADDR 0 4 		% load p
LOAD
PUSH MACHINE_FALSE 	% negate p
EQ
ADDR 0 5 		% load q
LOAD
% parameter n
% outer function F call
PUSH UNDEFINED 		% allocate space for return value
PUSH 3-28.2 		% load return address (points to OUTER "ADDR 1 2")
ADDR 1 0 		% push existing display 1 address
% inner function F call
PUSH UNDEFINED 		% allocate space for return value
PUSH 3-28.3 		% load return address (points to INNER "ADDR 1 2")
ADDR 1 0 		% push existing display 1 address
ADDR 0 1 		% load b
LOAD
ADDR 0 4 		% load p
LOAD
PUSH 3-14 		% load function F( b, p )
BR 			% call function F
ADDR 1 2 		% restore display register from INNER function F call
SETD 1
POP4 			% clear activation record except return value
% inner function F call END
% parameter p
ADDR 0 5 		% load q
LOAD
PUSH MACHINE_FALSE 	% negate q
EQ
PUSH 3-14 		% address of function F
BR 			% call function F( not p or q , ... , not q )
ADDR 1 2 		% restore display register from OUTER function F call
SETD 1
POP4 			% clear activation record except return value
% outer function F call END

% 3-29
% parameter p
ADDR 0 6 		% load r
LOAD
PUSH MACHINE_FALSE 	% negate r
EQ
ADDR 0 7 		% load s
LOAD
PUSH MACHINE_FALSE 	% negate s
EQ
OR 			% not r or not s
PUSH 3-29.1 		% address which points to false expression
BF
% true expression
PUSH MACHINE_TRUE 	% push constant true
PUSH 3-29.2 		% address which points over false expression
BR
% false expression
ADDR 0 7 		% load s
LOAD
PUSH MACHINE_FALSE 	% negate s
EQ
ADDR 0 5 		% load q
EQ 			% not s == q (which is equivalent to s not= q)
PUSH 3-19 		% address of procedure Q
BR 			% call procedure Q
ADDR 1 1 		% restore the display register
POP5 			% clear ALL activation record
% procedure Q call END
