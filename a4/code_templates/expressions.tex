% !TeX root = expressions.tex

\documentclass{article}
\usepackage{graphicx}
\usepackage[margin=0.8in]{geometry}
\usepackage{url}
\usepackage{amsmath}
\usepackage{float}
\usepackage{indentfirst}
\usepackage{listings}

\lstset{
  numbers=left,
  numberfirstline=true
}


% Your document starts here!
\begin{document}

% Define document title and author
	\title{Expressions Template}
	\author{Jasmeet Brar}
    \maketitle


\section{Accessing Constants}

If we ever encounter a constant numeric value in the AST, we can directly push the value onto the stack.

\section{Accessing Scalars}

To access a scalar, we would use the ADDR instruction to index into the array of display that we have so that we get the correct context of where the variable would be located, and then we would use an offset to go to the correct address of where the scalar would be located. We then use LOAD to load the value of the scalar from that address.

\section{Accessing Array Elements}

To access an array element, we can use ADDR to index into the display array, and get the address of the beginning of the stack, where the array would be located, and then it would add an offset which would jump us straight to the address of the array element. This offset can be calculated by the compiler, by using strides.

\section{Arithmetic and Comparison Operators}

All the binary operations have this form: \textit{expression} \textbf{operator} \textit{expression}. In the AST, the \textbf{operator} node will be the parent node of both the operand expressions. So when we are generating code for a binary operations, we must generate the code for both operands first, and then we generate code for the operation itself.

Assume that for each binary operation, code is generated for each operand expression, and the result of each operand is stored on the stack, where the left operand's result is stored first, followed by the right operand's.

\subsection{Arithmetic Operators}

For each of the arithmetic operators, $+,-,*,/$, there is a single machine instruction associated with each one of them, that is: ADD, SUB, MUL, and DIV respectively. So the code we generate is simply the instruction of the given operation.

\subsection{Comparison Operators}

For the $<$ operator, we have LT instruction that can directly compute if one operand is less than the other. So we just call LT.

For the $>$ operator, we can swap the arguments that are on the top of the stack, so that we just have to generate code for $<$, which is LT:

\begin{lstlisting}
    SWAP;
    LT;
\end{lstlisting}

The $=$ operator has a single machine instruction that can directly compute it, which is EQ.

As for \textbf{'not'} $=$ operator, we can first check the equality, with the EQ, and then push the value of false in to the stack, so that we can check if the result of the equality is actually false. The code we would generate is:

\begin{lstlisting}
    EQ;
    PUSH MACHINE_FALSE;
    EQ;
\end{lstlisting}

As for the $<=$ operator, notice that $x \leq y \equiv \lnot(x > y)$. To generate code for the \textbf{'not'}, we are simply going to push 
"MACHINE\_FALSE" into the stack, and then check if it equals the operand, to invert the result, as shown in the next section. From this, we can generate the following code:

\begin{lstlisting}
    SWAP;
    LT;
    PUSH MACHINE_FALSE;
    EQ;
\end{lstlisting}

As for the $>=$ operator, notice that $x \geq y \equiv \lnot(x < y)$. The code we generate for this is the following:

\begin{lstlisting}
    LT;
    PUSH MACHINE_FALSE;
    EQ;
\end{lstlisting}

\section{Logical Operators}

As for the \textbf{'and'} operator, we need to first execute the instructions for the left operand first, so that we can determine if we need to proceed with executing instructions for the second operand. In this case, as we're going through the AST tree, we'll generate the following code:

\begin{lstlisting}
    (Instructions for the first operand)
    PUSH address_1
    BF;
    (Instructions for the second operand)
    PUSH address_2
    BR;
    PUSH MACHINE_FALSE;
\end{lstlisting}

Line 1 is the instructions for the first operand, which will in the end, push its result onto the stack. Line 2 is when we're pushing address\_1, which is the address to line 7 onto the stack. This is done so that if the first operand is false, we can jump using the BF instruction on line 3 to line 7, which will push false onto the stack. The value of address\_1 cannot be determined right away, since we would have to jump over all the instructions that would appear for the second operand, as shown in line 4. So in this case, we would generate all the other instructions, and then determine the address of line 7.

Line 4 is of course all the instructions for the second operand, and this follows after line 3, meaning that the first operand is true. After executing all the instructions for the second expression, its result would appear in the stack, and that would be the result of the entire \textbf{'and'} operation. Line 5 us when we are pushing address\_2, which is the address of the line after line 7, to bypass the instruction that would push false onto the stack, since the final result of the whole \textbf{'and'} operation is already on the stack due to the execution of all the instructions on line 4. Line 6 is the unconditional branch that would make this work, and line 7 is the instruction to push false to the stack if the first operand was false.

As for the \textbf{'or'} operator, the code that is to be generated is similar to the code generated for the \textbf{'and'} operator, since one requires going through both operands to determine if the overall result is true, and the other does the same to determine if it is false. In this case, we generate the following code:

\begin{lstlisting}
    (Instructions for the first operand)
    PUSH MACHINE_FALSE;
    EQ;
    PUSH address_1
    BF;
    (Instructions for the second operand)
    PUSH address_2
    BR;
    PUSH MACHINE_TRUE;
\end{lstlisting}

At the beginning of all this, we generate instructions for the first operand, since we need to determine the result of that before we consider about executing the instructions for the second operand. Since we only have an instruction that branches if the condition is false, lines 2-3 is needed to invert the result, so that the BF instruction on line 5 would branch if the first operand is true. Line 4 is when we're pushing address\_1, which is the address of line 9, onto the stack, so that the BF instruction would actually branch us to the line where we would add back the value of true onto the stack, for the entire \textbf{'or'} operation. The value of address\_1 would be computed after we generate the rest of the instructions.

Line 6 is all the instructions for the second operand, which will get executed if the first operand was false. Line 7 is when we're pushing address\_2 onto the stack, which is the address of the line after line 9, to bypass the instruction to add true onto the stack, since the result we get from executing all the instructions for the second operand would've already pushed the result of the entire \textbf{'or'} operation onto the stack. Line 8 does the unconditional branching that would make this work, and line 9 is the instruction to push true onto the stack, if the first operand's result is true.

As for the \textbf{'not'} operator, we can just compare the operand with the value of false in order to flip the boolean value. The code that will be generated is:

\begin{lstlisting}
    (Instructions for the operand)
    PUSH MACHINE_FALSE;
    EQ;
\end{lstlisting}

\section{Conditional Expressions}

Conditional statements have the form of: (condition ? expression\_1 : expression\_2)

Where expression\_1 is the expression that would result from this should the condition be true, and expression\_2 is the expression should the condition be false. Implementing this should be straight forward with branching:

\begin{lstlisting}
    (Instructions for condition)
    PUSH address_1
    BF;
    (Instructions for expression_1)
    PUSH address_2
    BR;
    (Instructions for expression_2)
\end{lstlisting}

First we must generate the code for the condition, which would in the end push a boolean value onto the stack. At line 2 we're pushing address\_1 onto the stack, which is the address of line 7, at the beginning of the instructions for the second operand. This value is pushed so that we can branch off should the condition be false, and this value would be determined after we generate the rest of the instructions, since the number of instructions to jump over would vary.

Line 3 is the actual BF instruction, which would branch to line 7, if the condition is false. Line 4 contains all the instructions for expression\_1, and this proceeds after the BF instruction, meaning that the condition would be true before we start executing instructions for expression\_1. Line 5 pushes address\_2 onto the stack, which is the address of the line after line 7, to bypass all the instructions for expression\_2. This is needed since, we only need to execute expression\_1 if the condition is true. Just like before, the value of address\_2 would be determined after we execute the rest of instructions, since the number of instructions to jump over would vary. Line 6 is the instruction for the unconditional branch to actually perform the jump needed after executing all the instructions for expression\_1. Line 7 contains all the instructions for expression\_2.

\end{document}