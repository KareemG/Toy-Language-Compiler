% !TeX root = expressions.tex

\documentclass{article}
\usepackage{graphicx}
\usepackage[margin=0.8in]{geometry}
\usepackage{url}
\usepackage{amsmath}
\usepackage{float}
\usepackage{indentfirst}
\usepackage{listings}

\lstset{
  numbers=left,
  numberfirstline=true
}


% Your document starts here!
\begin{document}

% Define document title and author
	\title{Expressions Template}
	\author{Jasmeet Brar}
    \maketitle


\section{Arithmetic and Comparison Operators}

All the binary operations have this form: \textit{expression} \textbf{operator} \textit{expression}. In the AST, the \textbf{operator} node will be the parent node of both the operand expressions. So when we are generating code for a binary operations, we must generate the code for both operands first, and then we generate code for the operation itself.

Assume that for each binary operation, code is generated for each operand expression, and the result of each operand is stored on the stack, where the left operand's result is stored first, followed by the right operand's.

\subsection{Arithmetic Operators}

For each of the arithmetic operators, $+,-,*,/$, there is a single machine instruction associated with each one of them, that is: ADD, SUB, MUL, and DIV respectively. So the code we generate is simply the instruction of the given operation.

\subsection{Comparison Operators}

For the $<$ operator, we have LT instruction that can directly compute if one operand is less than the other. So we just call LT.

For the $<=$ operator, we can notice that this is the same as first comparing if the left operand is the less than the right, then compare that they are the same, and then return the result that is the \textbf{or} of the two operations. LT is the instruction to for $<$, EQ is the instruction for $=$, and OR is the operator for \textbf{or}. Thus we can generate the following code:

\begin{lstlisting}
    y := top; POP;
    x := top; POP;
    PUSH x;
    PUSH y;
    PUSH x;
    PUSH y;
    LT;
    x := top; POP;
    EQ;
    PUSH x;
    OR;
\end{lstlisting}

Additional instructions for PUSH and POP had to be added, since LT and EQ would be popping the arguments out of the stack, but we need the operands being passed to the operators to be the same, hence the instructions in lines 1-6 are needed to store the operands, duplicate, and push them into the stack so that we have two copies of each operands, and we maintain their order. Instruction on line 8 is needed to store the result that was pushed by LT, and line 10 is needed to push the result of LT back to the stack, so that it can be used by OR.

For the $>$ operator, we can swap the arguments that are on the top of the stack, so that we just have to generate code for $<$, which is LT:

\begin{lstlisting}
    SWAP;
    LT;
\end{lstlisting}

As for the $>=$ operator, we can swap the arguments on the top of the stack, so that this problem now becomes generating code for $<=$, which we had just did earlier:

\begin{lstlisting}
    SWAP;
    y := top; POP;
    x := top; POP;
    PUSH x;
    PUSH y;
    PUSH x;
    PUSH y;
    LT;
    x := top; POP;
    EQ;
    PUSH x;
    OR;
\end{lstlisting}

The $=$ operator has a single machine instruction that can directly compute it, which is EQ.

As for \textbf{'not'} $=$ operator, we can first check the equality, with the EQ, and then push the value of false in to the stack, so that we can check if the result of the equality is actually false. The code we would generate is:

\begin{lstlisting}
    EQ;
    PUSH MACHINE_FALSE;
    EQ;
\end{lstlisting}

\section{Logical Operators}

As for the \textbf{'and'} operator, we need to first execute the instructions for the left operand first, so that we can determine if we need to proceed with executing instructions for the second operand. In this case, as we're going through the AST tree, we'll generate the code for the first operand, followed by:

\begin{lstlisting}
    PUSH pc;
    PUSH num;
    ADD;
    BF;
    (Instructions for the second operand)
    PUSH pc;
    PUSH 5;
    ADD;
    BR;
    PUSH MACHINE_FALSE;
\end{lstlisting}

Lines 1-3 is when we're trying to add pc+num to the stack, where pc is the program counter, and num is the value that we add to pc, so that we would end up jumping to line 10 in this example, should the first operand give us false. The value of num cannot be determined right away, since we would have to jump over all the instructions that would appear for the second opperand, as shown in line 5. So in this case, we would generate all the other instructions, and then determine the value we add to pc to jump to line 10. Line 4 is when we do the actual branching should the value we get for the first operand is false.

Line 5 is of course all the instructions for the second operand, and this follows after line 4, meaning that the first operand is true. After executing all the instructions for the second expression, its result would appear in the stack, and that would be the result of the entire \textbf{'and'} operation. Lines 6-8 is when we push pc+5 to the stack, which is the address after the instruction on line 10. This is needed to jump over the statement that pushes false to the stack, since the instructions of our expression would've already placed its result on the stack. Line 9 is the unconditional branch that would make this work, and line 10 is the instruction to push false to the stack if the first operand was false.

As for the \textbf{'or'} operator, the code that is to be generated is similar to the code generated for \textbf{'and'}, since one requires going through both operands to determine if the overall result is true, and the other does the same to determine if it is false. We start off by having the code generated for the first operand, followed by the following code:

\begin{lstlisting}
    PUSH MACHINE_FALSE;
    EQ;
    PUSH pc;
    PUSH num;
    ADD;
    BF;
    (Instructions for the second operand)
    PUSH pc;
    PUSH 5;
    ADD;
    BR;
    PUSH MACHINE_TRUE;
\end{lstlisting}

Since we only have an instruction that branches if the condition is false, lines 1-2 is needed to invert the result, so that the BF instruction on line 6 would branch if the first operand is true. Like before, lines 3-5 is needed to push pc+num to the stack, which is the address of line 12, where we are pushing the value true to our stack. The value of num would be computed after we generate the rest of the code. Line 7 is all the instructions for the second operand, which will get executed if the first operand was false. Lines 5-8 pushes pc+5 to the stack, which is the address after line 10, so we can jump to that line, and bypass the instruction to push false to the stack, since the actual result of the whole \text{'or'} operation has already been pushed onto the stack by line 7. Line 11 does the unconditional branching that bypasses the next line.

As for the \textbf{'not'} operator, we can just compare the operand with the value of false in order to flip the boolean value. The code that will be generated is:

\begin{lstlisting}
    PUSH MACHINE_FALSE;
    EQ;
\end{lstlisting}

\section{Conditional Expressions}

Conditional statements have the form of: (condition ? expression\_1 : expression\_2)

Where expression\_1 is the expression that would result from this should the condition be true, and expression\_2 is the expression should the condition be false. Implementing this should be straight forward with branching:

\begin{lstlisting}
    (Instructions for condition)
    PUSH pc;
    PUSH num_1;
    ADD;
    BF;
    (Instructions for expression_1)
    PUSH pc;
    PUSH num_2;
    ADD;
    BR;
    (Instructions for expression_2)
\end{lstlisting}

First we must generate the code for the condition, which would in the end push a boolean value onto the stack. Then lines 2-4 is needed to push pc+num\_1 onto the stack, which is the address of line 11. The value of num\_1 would have to be calculated after we generate the rest of the code, since the number of instructions for expression\_1 can vary.

Line 5 is the actual BF instruction, which would branch to line 11, if the condition is false. Line 6 contains all the instructions for expression\_1. Lines 7-9 pushes pc+num\_2 onto the stack, which is the address of the line after line 11, which would bypass all the instructions for expression\_2, when the condition was true. Just like before, num\_2 would have to be determined after we generate the rest of the code since the number of instructions for expression\_2 can vary. Line 10 is the unconditonal branch to bypass the next line, like what we said before. Line 11 contains all the instructions for expression\_2.

\end{document}