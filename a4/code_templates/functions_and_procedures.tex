\documentclass{article}
\usepackage{graphicx}
\usepackage[margin=0.8in]{geometry}
\usepackage{url}
\usepackage{amsmath}
\usepackage{float}
\usepackage{indentfirst}
\usepackage{listings}

\lstset{
  numbers=left,
  numberfirstline=true
}

\begin{document}

\section{Activation Record} \label{rec}

The activation record will consist of couple of informations in order for callee to gather all the necessary information to carry out the function/procedure, and for caller to successfully execute and return from the callee.

If it is a function, we will first reserve a space in stack in order to hold to return value. Such memory in the stack allows for callee to store its return value, and it also allows caller to retrieve the return value when the callee is done.

Then, for both function and procedure, we must push the return address to the stack. Such address will be used by the callee to return to the caller when it is done.

Finally, if the function or the procedure contains parameters. It will be included in the activation record as well.

All of the mentioned information must be stored in the activation record in this specific order at all times. For instance, an activation record for {\tt function F( m : integer , n : boolean) : integer} found in ``A4-3.488'' can be represented as such:

\begin{lstlisting}[language=]
param : n
param : m
return address
return value
\end{lstlisting}

Note that in this example, the stack grows up. Hence {\tt param : n} is located on top of the stack. A simpler activation record can be observed with {\tt procedure P} from same sample file:

\begin{lstlisting}[language=]
return address
\end{lstlisting}

In this case, only the return address is necessary, since it is a procedure (no return value necessary) without any parameters.

\section{Procedure and Function Entrance Code}

When the function or a procedure enters, the activation record needs to be properly set up. Please refer to {\it Section \ref{rec}} for more information in regards to the information contained within activation record.

Once the activation record has been set up, we must also set the display register of an index equivalent to the caller's lexical level. More information on this can be found in {\it Section \ref{display}}. Now, we can jump to the callee, which effectively allows the program to start the execution of called function.

Let us take {\tt function F(m : integer , n : boolean) : integer} again as an example. The following instructions must be executed:

\begin{lstlisting}
SETD (current display LL)
PUSH -1
PUSHMT
ADDR (address of argument for m)
ADDR (address of argument for n)
ADDR (address of F)
BR
\end{lstlisting}

Note that the initial {\tt PUSH -1} will be a placeholder used for return value. Furthermore, our implementation implies that the caller must set up the stack before calling the callee.

\section{Procedure and Function Exit Code}

Do note that in terms of exit code, procedure and functions differs due to the fact that functions must return a value, while procedures do not. The cleanup which caller must do is similar.

For all functions, we must first load the return value into the address which we have reserved for return value. Then for both functions and procedures, we can branch back to the return address in order to return to the caller function.

Below is an example of exiting function {\tt function F(m : integer , n : boolean) : integer}. Do note that for procedure, instead of load the return value to $LL + 0x0$, we would instead simply use that value of that address to unconditionally branch back to caller, since we will not be storing the return value for procedures.

\begin{lstlisting}
PUSH (return value)
ADDR (last display number) 0x0
LOAD
ADDR (last display number) 0x4
BR
\end{lstlisting}

\section{Parameter Passing}

Parameter passing is done via loading the values to the parameters onto the stack in left-to-right order. This is done after we have populated return values (if the callee is a function) and return address. We can statically determine the address of the given parameter 

\section{Function Call and Function Value Return}

\section{Procedure Call}

\section{Display Management Strategy} \label{display}

When the function references a variable outside of the scope, we must create a reference to the said variable for the correctness of the program. This can be done by scanning through the function and gathering all of the references that were made in the said function. Then, we can add the addreses to the references variables in one of the {\tt display} registers. Then, every time the variable gets references, we can load the address from the corresponding display register.

% Explain in detail how we can manage

\end{document}
