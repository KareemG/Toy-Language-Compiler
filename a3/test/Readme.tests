
Failing Cases: These cases contain syntactically correct programs with semantic errors which must be caught by the semantic analyzer step. 
               Hence, these test cases also test symbol table functionality such as scope and variable/return type tracking.
add_bools.488                 : test that adding two booleans fail
add_int_and_bool.488          : test that adding an integer and boolean fail
array_type_mismatch.488       : test that inserting a value of a wrong type in an array fail
assign_bool_to_int.488        : test that assigning a boolean to an integer fail
assign_int_to_bool.488        : test that assigning an integer to a boolean fail
assign_undeclared_var.488     : test that assigning a value to an undeclared variable fail
bad_array.488                 : test that declaring an array with invalid bounds (bound 1 > bound 2) fail
call_undeclared_function.488  : test that calling an undeclared function fail
call_undeclared_procedure.488 : test that calling an undeclared procedure fail
call_variable.488             : test that calling a variable as a function fail
different_parameter_type.488  : test that passing an argument with the wrong type fail
duplicate_definition.488      : test that duplicating a function definition with a variable definition fail
duplicate_function.488        : test that redeclaring a function/procedure fail
duplicate_variable.488        : test that redeclaring a variable fail
excessive_parameters.488      : test that too many arguments to a function fail
exit_invalid.488              : test that using the exit statement to break out more loops than they currently exist fail
exit_zero.488                 : test that using the exit statement to break out of 0 loops fail
external_exit.488             : test that using the exit statement outside of a loop fail
external_return.488           : test that using the return statement outside of a function fail
missing_parameters.488        : test that calling a function with missing arguments fail
no_parameters.488             : test that passing arguments to a function that has no parameters fail
no_return_stmt.488            : test that declaring function without a return statement fail
out_of_scope_function.488     : test that calling a function outside of scope fail
out_of_scope_variable.488     : test that using a variable outside of scope fail
return_from_func.488          : test that using a procedural return from a function fail
return_with_proc.488          : test that returning with a value in a procedure fail
sub_int_and_bool_expr.488     : test that subtraction between an integer and boolean fail
var_same_name_as_function.488 : test that declaring a variable with the same name of the function it is defined in fail
var_same_name_as_param.488    : test that declaring a variable with the same name of a parameter in its function fail
conditional_operator_different_return_type : test that a conditional operator with different result types fails
conditional_operator_different_types       : test that a conditional operator with different true and false return types fails

Passing tests: These are split into 2 categories - AST and Symbol Table

AST Test Cases: These programs are both syntactically and semantically correct, and the AST printed into the output must match with the verified one in the out files
array_1D.488                  : test that the AST for 1D arrays is valid
array_2D.488                  : test that the AST for 2D arrays is valid
exit.488                      : test that the AST for the exit statements is valid
expressions.488               : test that the AST for all the expressions is valid
functions.488                 : test that the AST for functions is valid
if_stmt.488                   : test that the AST for if statements is valid
loops.488                     : test that the AST for loops is valid
procedures.488                : test that the AST for procedures is valid
return.488                    : test that the AST for return statements is valid
scope_statements_only.488     : test that the AST for scopes is valid
A1a.488 - A1e.488             : Test programs from A1
---------- THE FOLLOWING TESTS ARE FROM A2 ----------
addition.488            : Checks that add operation syntax works
and.488                 : Checks that and operation syntax works
division.488            : Checks that division operation syntax works
equality.488            : Checks that equality operaton syntax works
greater-than-equal.488  : Checks that greater than or equal to operation syntax works
greater-than.488        : Checks that greater than operation syntax works
inequality.488          : Checks that the inequality operation syntax works
less-than-equal.488     : Checks that the less than or equal to operation syntax works
less-than.488           : Checks that the less than operation syntax works
multiple-operations.488 : Checks that having multiple different operations in one line syntax works
multiplication.488      : Checks that multiplication operation syntax works
or.488                  : Checks that or operation syntax works
subtraction.488         : Checks that subtraction operation syntax works
2D-boolean-array.488 : Checks the syntax for declaring and assigning 2D boolean array works
2D-integer-array.488 : Checks the syntax for declaring and assigning 2D integer array works
boolean-array.488    : Checks the syntax for declaring and assigning boolean array works
boolean.488          : Checks the syntax for declaring and assigning boolean to a variable works
integer.488          : Checks the syntax for declaring and assigning integer to a variable works
integer-array.488    : Checks the syntax for declaring and assigning integer array works
if-then-else.488     : Checks that the if then else syntax works
if-then.488          : Checks that the if then syntax works
read.488             : Checks that read statement syntax works
ternery-operator.488 : Checks that the ternery operator syntax works
write-newline.488    : Checks that the write statement with newline syntax works
write.488            : Checks that the write statement syntax works
exit-integer-when.488 : Checks that the exit integer when statement syntax works when exiting out of an integer loop
exit-integer.488      : Checks that the exit integer syntax works when exiting out of an integer loop
exit-when.488         : Checks that the exit when syntax works when exiting out of a containing loop
exit.488              : Checks that the exit syntax works when exiting out of a containing loop
repeat-until-loop.488 : Checks that the repeat until loop syntax works
while-loop.488        : Checks that the while loop syntax works
boolean-function.488        : Checks that the syntax for declaring and calling a function that returns a boolean works
function-from-function.488  : Checks that the syntax for declaring and calling a function from a function works
function-multiple-args.488  : Checks that the syntax for declaring and calling a function with multiple arguments works
integer-function.488        : Checks that the syntax for declaring and calling a function that returns an integer works
procedure-multiple-args.488 : Checks that the syntax for declaring and calling a procedure with multiple arguments works
procedure.488               : Checks that the syntax for declaring and calling a procedure works
recursive-function.488      : Checks that the syntax for declaring and calling a recursive function works
recursive-procedure.488     : Checks that the syntax for declaring and calling a recursive procedure works

Symbol Table Test Cases: These programs are both syntactically and semantically correct, and the symbol table must match the expected symbol table in the out files
function_scope.488            : test that the symbol table can handle function scopes
global_scope.488              : test that the symbol table can handle global scopes
loop_scope.488                : test that the symbol table can handle loop scopes
nested_scopes.488             : test that the symbol table can handle nested scopes and shadowing
shadow_global_scope.488       : test that the symbol table can handle variables shadowing global scope
procedures.488                : test that the symbol table can handle a function and procedure with the same named parameters
shadow_parameters.488         : test that the symbol table can handle shadowing global variables in a function's parameters
shadow_local_variables.488    : test that the symbol table can handle shadowing global variables from a function's local variables
shadow_functions.488          : test that the symbol table can handle shadowing a function with another function in another scope
shadow_procedures.488         : test that the symbol table can handle shadowing a procedure with another procedure in another scope
