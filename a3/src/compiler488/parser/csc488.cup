/*
    DEFINITIONS for CSC488S Source Language Winter 2016
*/

package compiler488.parser;

// TODO: You can add Java import statements here as necessary
import compiler488.ast.*;
import compiler488.ast.stmt.*;
import compiler488.ast.expn.*;
import compiler488.ast.type.*;
import compiler488.ast.decl.*;

/*
    SYMBOL LISTS

    CUP reserved words are case-sensitive and cannot be used as names of
    terminals or non-terminals. This list includes the following:

        action code extends import init left non nonassoc nonterminal package
        parser precedence right scan start super terminal with

*/

// Keyword terminals returned by the scanner (with no value attached):
terminal AND, OR, NOT, TRUE, FALSE;
terminal BOOLEAN, INTEGER, FUNCTION, PROCEDURE;
terminal DO, ELSE, EXIT, IF;
terminal READ, REPEAT, RETURN, NEWLINE, THEN, UNTIL;
terminal VAR, WHEN, WHILE, WITH, WRITE;

// Special-character terminals (with no value attached):
terminal L_PAREN, R_PAREN, L_SQUARE, R_SQUARE, L_CURLEY, R_CURLEY;
terminal EQUAL, GREATER, LESS, COMMA, DOT, QUESTION, COLON;
terminal PLUS, MINUS, TIMES, DIVIDE;

// Terminals returned by the scanner that carry a value of a specific Java type:
terminal String     IDENT;
terminal Integer    INTCONST;
terminal String     TEXTCONST;

/*
    To define non-terminals that return no value:

        nonterminal nameList;

    To define non-terminals that do return a value (think AST generation):

        nonterminal JavaType nameList;
*/

nonterminal	variablenames,		output	;
nonterminal	variable			;
nonterminal	variablename 			;
nonterminal	inputs, outputs;
nonterminal	conjunction, negation;

nonterminal Program program;
nonterminal Scope scope;

nonterminal Stmt statement, matchedStatement, unmatchedStatement;
nonterminal ProcedureCallStmt procedureCall;
nonterminal ASTList<Stmt> statements;

nonterminal Declaration declaration, parameter;
nonterminal ASTList<Declaration> declarations;
nonterminal ASTList<ScalarDecl> parameters;

nonterminal Expn expression, arithExpn, term, factor, primary;
nonterminal ASTList<Expn> arguments;
nonterminal ConstExpn constant;
nonterminal CompareExpn compareExpn;

nonterminal Type type;

nonterminal Integer[] bound; // ???
nonterminal Integer generalBound; // ???

/*
    PLEASE NOTE: Your grammar may not use the 'precedence' feature of JCup to
    resolve the precedence of arithmetic operators.

    The two lines below must remain commented out;
*/

// precedence left PLUS, MINUS;
// precedence left TIMES, DIVIDE; // Higher precedence.

//  Use precedence to associate else with closest if
precedence   left ELSE ;

/*
    GRAMMAR SECTION
*/

// This specifies the initial symbol of the grammar.
start with program;

/*
    Notice that sometimes the action must be inside the production rule, not after
    it. This is a subtle yet significant difference from YACC. This is because the
    CUP parser is looking ahead one token. It ALWAYS reads one more token before it
    will act on the production.
 */

program ::= scope {: RESULT = new Program(); :}                           // the main program
    ;

scope
    ::= L_CURLEY declarations:decls statements:stmts R_CURLEY {: RESULT = new Scope(); :}  // scope with declarations and statements
    |   L_CURLEY statements R_CURLEY {: RESULT = new Scope(); :}                // scope with statements only
    |   L_CURLEY R_CURLEY {: RESULT = new Scope(); :}                           // empty scope
    ;

statements
    ::= statement:stmt {: RESULT = new ASTList<Stmt>(stmt); :}                       // sequence of statements
    |   statements:stmts statement:stmt {: RESULT = stmts.append(stmt); :}
    ;

declarations
    ::= declaration:decl {: RESULT = new ASTList<Declaration>(decl); :}                     // sequence of declarations
    |   declarations:decls declaration:decl {: RESULT = decls.append(decl); :}
    ;

statement
    ::= matchedStatement:stmt {: RESULT = stmt; :}
    |   unmatchedStatement:stmt {: RESULT = stmt; :}
    ;

matchedStatement
    ::= variable COLON EQUAL expression                             // assignment statement
    |   IF expression THEN matchedStatement ELSE matchedStatement   // if statements
    |   WHILE expression DO statement                               // while statement
    |   REPEAT statements UNTIL expression                           // repeat statement
    |   EXIT                                                        // exit statements
    |   EXIT INTCONST
    |   EXIT WHEN expression
    |   EXIT INTCONST WHEN expression
    |   RETURN WITH expression
    |   RETURN                                                      // return statements
    |   WRITE outputs                                               // input/output statements
    |   READ inputs
    |   procedureCall                                               // procedure call
    |   scope                                                       // embedded scope
    ;

unmatchedStatement
    ::= IF expression:expr THEN statement:stmt {: RESULT = new IfStmt(expr, stmt); :}
    |   IF expression:expr THEN matchedStatement:matched ELSE unmatchedStatement:unmatched {: RESULT = new IfStmt(expr, matched, unmatched); :}
    ;

procedureCall
    ::= IDENT:ident {: RESULT = new ProcedureCallStmt(ident); :}                           // call procedure with no parameters
    |   IDENT:ident L_PAREN arguments:args R_PAREN {: RESULT = new ProcedureCallStmt(ident, args); :} // call procedure with parameters
    ;

declaration
    ::= VAR variablenames COLON type                                // declare scalar/array variables
    | FUNCTION IDENT:ident COLON type:type scope:scope // declare function
      {: RESULT = new RoutineDecl(ident, type, scope); :}
    | FUNCTION IDENT:ident L_PAREN parameters:params R_PAREN COLON type:type scope:scope
      {: RESULT = new RoutineDecl(ident, type, params, scope); :}
    | PROCEDURE IDENT:ident scope:scope                // declare procedure
      {: RESULT = new RoutineDecl(ident, scope); :}
    | PROCEDURE IDENT:ident L_PAREN parameters:params R_PAREN scope:scope
      {: RESULT = new RoutineDecl(ident, params, scope); :}
    ;

variablenames
    ::= variablename                                // list of variables being declared
    |   variablenames COMMA variablename
    ;

variablename
    ::= IDENT                                       // scalar variable
    |   IDENT L_SQUARE bound R_SQUARE               // 1-dimension array variable
    |   IDENT L_SQUARE bound COMMA bound R_SQUARE   // 2-dimensional array variable
    ;

bound
    ::= INTCONST                                    // positive array bound
    |   generalBound DOT DOT generalBound           // upper and lower bounds
    ;

generalBound
    ::= INTCONST                    // positive integer bounds
    |   MINUS INTCONST              // negative integer bounds
    ;

type
    ::= INTEGER {: RESULT = new IntegerType(); :} // integer type
    |   BOOLEAN {: RESULT = new BooleanType(); :} // boolean type
    ;

outputs
    ::= output                      // list of output expressions
    |   outputs COMMA output
    ;

output
    ::= expression                  // integer expression
    |   TEXTCONST                   // text constant
    |   NEWLINE                     // newline constant
    ;

inputs
    ::= variable                    // list of variables being read into
    |   inputs COMMA variable
    ;

arguments
    ::= expression:expr {: RESULT = new ASTList<Expn>(expr); :} // list of function/procedure arguments
    |   arguments:args COMMA expression:expr {: RESULT = args.append(expr); :}
    ;

parameters
    ::= parameter                   // list of function/procedure formal parameters
    |   parameters COMMA parameter
    ;

parameter
    ::= IDENT COLON type            // declare one parameter
    ;

expression
    ::= conjunction                 // disjunctions, associate left-to-right
    |   expression OR conjunction
    ;

conjunction
    ::= negation                    // conjunctions, associate left-to-right
    |   conjunction AND negation
    ;

negation
    ::= compareExpn                 // negations
    |   NOT negation
    ;

compareExpn
    ::= arithExpn                                   // comparisons, do not associate
    |   arithExpn EQUAL arithExpn
    |   arithExpn NOT EQUAL arithExpn
    |   arithExpn LESS arithExpn
    |   arithExpn LESS EQUAL arithExpn
    |   arithExpn GREATER arithExpn
    |   arithExpn GREATER EQUAL arithExpn
    ;

arithExpn
    ::= term:term {: RESULT = term; :}                        // expressions, associate + , - left-to-right
    |   arithExpn:left PLUS term:right
        {: RESULT = new ArithExpn("+", left, right); :}
    |   arithExpn:left MINUS term:right
        {: RESULT = new ArithExpn("-", left, right); :}
    ;

term
    ::= factor                      // terms, associate * , / left-to-right
    |   term:left TIMES factor:right
        {: RESULT = new ArithExpn("*", left, right); :}
    |   term:left DIVIDE factor:right
        {: RESULT = new ArithExpn("/", left, right); :}
    ;

factor
    ::= primary:primary {: RESULT = primary; :}                     // unary minus
    |   MINUS factor:fact {: RESULT = new UnaryMinusExpn(fact); :}
    ;

primary
    ::= constant:constant {: RESULT = constant; :}                                                            // integer or boolean constant
    |   variable                                                            // scalar, array variable or function call
    |   IDENT L_PAREN arguments R_PAREN                                     // function call
    |   L_PAREN expression R_PAREN                                          // parenthesized expression
    |   L_PAREN expression QUESTION expression COLON expression R_PAREN     // conditional expression
    ;

constant
    ::= INTCONST:integer {: RESULT = new IntConstExpn(integer); :} // integer constant
    |   TRUE {: RESULT = new BoolConstExpn(true); :} // constant true
    |   FALSE {: RESULT = new BoolConstExpn(false); :} // constant false
    ;

variable
    ::= IDENT                                                               // scalar variable or function call
    |   IDENT L_SQUARE expression R_SQUARE                                  // element of 1-dimensional array
    |   IDENT L_SQUARE expression COMMA expression R_SQUARE                 // element of 2-dimensional array;
    ;
