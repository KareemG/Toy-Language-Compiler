Our symbol table implementation consists of a reference to single ScopeNode
object and couple of functions which interacts with the aforementioned
ScopeNode.

The following are the four functions:
- get(String key) : given a key value, go through the ScopeNode and its parents
                    to attempt to retrieve the value linked to the key.
                    If there are no reference to the key, then the program will
                    assert.
- put(String key, BaseAST value) : given a key and value, stores the combination
                                   in the current ScopeNode's hash table. If
                                   there is a same key in the hash table
                                   already, then assert.
- enterScope() : Called everytime semantic analyzer notices a new scope. We will
                 create a new ScopeNode object and link the previous ScopeNode
                 as its parent.
- exitScope() : Called everytime semantic analyzer notices that it is leaving
                the scope. We will set current ScopeNode's parent as the new
                current ScopeNode (root). Furthermore, we will store the
                previous ScopeNode in archive. This may not be necessary at the
                moment, but may come in handy if we need to traverse the AST
                again, or need to generate a file out of it.

ScopeNode object can be described as a node of current scope context. By
separating each scope this way, we can still have the reference to the outer
scope (and its declarations). ScopeNode holds the actual hash table of symbols.